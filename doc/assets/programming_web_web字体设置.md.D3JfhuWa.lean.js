import{_ as i,c as a,a2 as t,o as n}from"./chunks/framework.CqbvlPrP.js";const c=JSON.parse('{"title":"Web端字体切割压缩方案","description":"","frontmatter":{},"headers":[],"relativePath":"programming/web/web字体设置.md","filePath":"programming/web/web字体设置.md"}'),p={name:"programming/web/web字体设置.md"};function e(l,s,h,r,k,o){return n(),a("div",null,s[0]||(s[0]=[t(`<h1 id="web端字体切割压缩方案" tabindex="-1">Web端字体切割压缩方案 <a class="header-anchor" href="#web端字体切割压缩方案" aria-label="Permalink to &quot;Web端字体切割压缩方案&quot;">​</a></h1><p>今天接到一个系统需求，需要将系统内的文字替换为鸿蒙OS的字体（developer.huawei.com/consumer/cn…），但是鸿蒙OS的字体单Regular的文件就有8M+。这个直接放到网页上，会极大影响使用体验。</p><p>于是乎，开始考虑怎么开始对字体文件进行压缩。</p><h2 id="第一种方案" tabindex="-1">第一种方案 <a class="header-anchor" href="#第一种方案" aria-label="Permalink to &quot;第一种方案&quot;">​</a></h2><p>一般来说，字体格式体积由大到小排列（性能从差到好）：</p><p>ttf，eot(IE8)，woff，woff2</p><p>从官网下载的鸿蒙字体是ttf格式的，尝试用了woff2格式的（github.com/IKKI2000/ha…），但是还是有4M多。对于Web端来说，还是太大了。</p><h2 id="第二种方案" tabindex="-1">第二种方案 <a class="header-anchor" href="#第二种方案" aria-label="Permalink to &quot;第二种方案&quot;">​</a></h2><p>把系统内未使用过的汉字裁掉，只保留系统内使用的汉字，这样就可以大大减少字体文件体积。但是呢这种方式只适用于固定内容的网页，像一些动态内容（服务端返回的汉字，评论等）就没法适应。</p><p>这种方式可以使用 Font-spider-Plus 组件进行压缩。具体方法可以看到组件文档。</p><h2 id="第三种方案" tabindex="-1">第三种方案 <a class="header-anchor" href="#第三种方案" aria-label="Permalink to &quot;第三种方案&quot;">​</a></h2><p>上面两种方式，对于我来说都不太理想，于是只能继续寻找方案。很好奇，鸿蒙的官网也是用的鸿蒙的字体，那它是怎么兼顾性能的呢？</p><p>通过Devtool能看到，官网加载的字体文件非常多，但是每个只有几十kb。像是被切割成了N份。</p><p>于是翻看对应的css文件，发现了这一句注释</p><p>/** generated by <a href="https://github.com/voderl/font-slice" target="_blank" rel="noreferrer">https://github.com/voderl/font-slice</a> */</p><p>进入github仓库一看，发现了今天的主角 font-slice。（组件Demo地址）</p><p>效果 以得意黑字体为例为例：</p><p>处理前 ttf 大小 2074KB，woff2 大小 928KB.</p><p>处理后每个类型的字体生成 95 个文件：</p><p>ttf 总大小为 2.3M (最小文件 3.4K，最大文件 55K)</p><p>woff2 总大小为 1.3M (最小文件 1.5K，最大文件 33K)</p><p>实际加载页面的体积由页面使用的字符决定，以该页面为例，只需要加载 386KB 就能覆盖全部字符。</p><p>原理 将中文字体按照 Google Fonts 的切割子集方案，生成多个较小体积的资源包。仅需加载小部分字体资源即可展示完整页面。</p><p>即它采用了机器学习等手段，将字体拆分成合适的粒度，比如把一个 4MB 的字体包分成 100 个 40KB 的字体包，这样的话，一般网页中使用到的中文也只是一部分字体，只需要加载多个资源包就能完全覆盖。同时，就算网页中有很多生僻字，需要付出的代价也只是多加载几个资源包。</p><p>使用</p><ol><li>安装</li></ol><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --save-dev</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> font-slice</span></span></code></pre></div><p>2.创建脚本</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> path</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;path&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> createFontSlice</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;font-slice&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createFontSlice</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // fontPath</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  fontPath: path.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(__dirname, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;YourPath.ttf&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // outputDir</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  outputDir: path.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(__dirname, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./output&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  fontFamily: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;HarmonyOS_SansSC&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 是否需要在生成完成后打开预览页面，默认为 true，如果为 false 不会生成 index.html 及启动服务器</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  preview: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><p>这一步所有的配置项可以查看：<a href="https://github.com/voderl/font-slice" target="_blank" rel="noreferrer">github.com/voderl/font…</a></p><ol start="3"><li>配置script 我是把这个脚本配置到了package.json的scripts里面，后续就可以通过npm run来运行了。这一步可自行决定。</li></ol><p>4.引入CSS 运行完成后，会输出font.css和切割成多份的字体文件。将css引入页面。页面内的地方就可以正常使用font-family了。</p><p>缺点 这种方式有个缺点，就是如果新出现的文字没有加载对应的分片，会有一瞬间的文字闪动。因为需要加载新的文字分片。</p><p>参考文档 web性能-字体优化-掘金 font-slice组件 字蛛+（Font-spider-plus） 鸿蒙字体下载</p><h2 id="方案四" tabindex="-1">方案四 <a class="header-anchor" href="#方案四" aria-label="Permalink to &quot;方案四&quot;">​</a></h2><p>vite-plugin-font 支持直接 import 导入，并且支持中文按需加载，不需要自己处理，还能嵌入到前端工具链。它底层的 cn-font-split 也是基于算法分割的。</p>`,36)]))}const E=i(p,[["render",e]]);export{c as __pageData,E as default};
