import{_ as e,c as t,a2 as a,o as r}from"./chunks/framework.CqbvlPrP.js";const h=JSON.parse('{"title":"pm2 使用方法，常用命令，及设置vue等前端项目开启启动，node,eggjs 等node项目开机启动","description":"","frontmatter":{},"headers":[],"relativePath":"programming/node/pm2常用命令.md","filePath":"programming/node/pm2常用命令.md"}'),m={name:"programming/node/pm2常用命令.md"};function s(o,p,n,l,i,d){return r(),t("div",null,p[0]||(p[0]=[a('<h1 id="pm2-使用方法-常用命令-及设置vue等前端项目开启启动-node-eggjs-等node项目开机启动" tabindex="-1">pm2 使用方法，常用命令，及设置vue等前端项目开启启动，node,eggjs 等node项目开机启动 <a class="header-anchor" href="#pm2-使用方法-常用命令-及设置vue等前端项目开启启动-node-eggjs-等node项目开机启动" aria-label="Permalink to &quot;pm2 使用方法，常用命令，及设置vue等前端项目开启启动，node,eggjs 等node项目开机启动&quot;">​</a></h1><h1 id="常用命令" tabindex="-1">常用命令 <a class="header-anchor" href="#常用命令" aria-label="Permalink to &quot;常用命令&quot;">​</a></h1><h2 id="安装pm2" tabindex="-1">安装pm2 <a class="header-anchor" href="#安装pm2" aria-label="Permalink to &quot;安装pm2&quot;">​</a></h2><p>$ npm install -g pm2 命令行全局安装pm2</p><p>$ pm2 logs 显示所有进程日志 $ pm2 stop all 停止所有进程 $ pm2 restart all 重启所有进程 $ pm2 reload all 0秒停机重载进程 (用于 NETWORKED 进程) $ pm2 stop 0 停止指定的进程 $ pm2 restart 0 重启指定的进程 $ pm2 startup 产生 init 脚本 保持进程活着 $ pm2 web 运行健壮的 computer API endpoint $ pm2 delete 0 杀死指定的进程 $ pm2 delete all 杀死全部进程</p><h2 id="用法" tabindex="-1">用法 <a class="header-anchor" href="#用法" aria-label="Permalink to &quot;用法&quot;">​</a></h2><p>$ npm install pm2 -g # 命令行安装 pm2 $ pm2 start app.js -i 4 #后台运行pm2，启动4个app.js # 也可以把&#39;max&#39; 参数传递给 start # 正确的进程数目依赖于Cpu的核心数目 $ pm2 start app.js --name my-api # 命名进程 $ pm2 list # 显示所有进程状态 $ pm2 monit # 监视所有进程 $ pm2 logs # 显示所有进程日志 $ pm2 stop all # 停止所有进程 $ pm2 restart all # 重启所有进程 $ pm2 reload all # 0秒停机重载进程 (用于 NETWORKED 进程) $ pm2 stop 0 # 停止指定的进程 $ pm2 restart 0 # 重启指定的进程 $ pm2 startup # 产生 init 脚本 保持进程活着 $ pm2 web # 运行健壮的 computer API endpoint (<a href="http://localhost:9615" target="_blank" rel="noreferrer">http://localhost:9615</a>) $ pm2 delete 0 # 杀死指定的进程 $ pm2 delete all # 杀死全部进程</p><p>运行进程的不同方式： $ pm2 start app.js -i max # 根据有效CPU数目启动最大进程数目 $ pm2 start app.js -i 3 # 启动3个进程 $ pm2 start app.js -x #用fork模式启动 app.js 而不是使用 cluster $ pm2 start app.js -x -- -a 23 # 用fork模式启动 app.js 并且传递参数 (-a 23) $ pm2 start app.js --name serverone # 启动一个进程并把它命名为 serverone $ pm2 stop serverone # 停止 serverone 进程 $ pm2 start app.json # 启动进程, 在 app.json里设置选项 $ pm2 start app.js -i max -- -a 23 #在--之后给 app.js 传递参数 $ pm2 start app.js -i max -e err.log -o out.log # 启动 并 生成一个配置文件 你也可以执行用其他语言编写的app ( fork 模式): $ pm2 start my-bash-script.sh -x --interpreter bash $ pm2 start my-python-script.py -x --interpreter python</p><h2 id="_0秒停机重载" tabindex="-1">0秒停机重载: <a class="header-anchor" href="#_0秒停机重载" aria-label="Permalink to &quot;0秒停机重载:&quot;">​</a></h2><p>这项功能允许你重新载入代码而不用失去请求连接。 注意： 仅能用于web应用 运行于Node 0.11.x版本 运行于 cluster 模式（默认模式） $ pm2 reload all</p><p>CoffeeScript: $ pm2 start my_app.coffee #这就是全部</p><p>PM2准备好为产品级服务了吗？ 只需在你的服务器上测试 $ git clone <a href="https://github.com/Unitech/pm2.git" target="_blank" rel="noreferrer">https://github.com/Unitech/pm2.git</a> $ cd pm2 $ npm install # 或者 npm install --dev ，如果devDependencies 没有安装 $ npm test</p><p>pm2 list 列出由pm2管理的所有进程信息，还会显示一个进程会被启动多少次，因为没处理的异常。</p><p>pm2 monit</p><p>监视每个node进程的CPU和内存的使用情况。</p><p>§ pm2 将 vue后台运行项目 pm2 start npm --name butterfly-front -- run serve § pm2 后台运行node项目 1， pm2 start -i 4 npm --name butterfly-server -- run dev 2、开机启动</p><p>pm2 save # 保存服务 pm2 startup # 把已启动服务加到systemd中 pm2 unstartup systemd # 删除自动启动服务</p>',17)]))}const c=e(m,[["render",s]]);export{h as __pageData,c as default};
