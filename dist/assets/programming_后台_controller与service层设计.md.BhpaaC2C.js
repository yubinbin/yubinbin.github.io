import{_ as o,c as r,a2 as p,o as l}from"./chunks/framework.CqbvlPrP.js";const t="/assets/img/program/%E5%90%8E%E5%8F%B0/1.gif",M=JSON.parse('{"title":"mvc 里controller 和service 职责如何划分？","description":"","frontmatter":{},"headers":[],"relativePath":"programming/后台/controller与service层设计.md","filePath":"programming/后台/controller与service层设计.md"}'),a={name:"programming/后台/controller与service层设计.md"};function i(n,e,s,d,c,h){return l(),r("div",null,e[0]||(e[0]=[p('<h1 id="mvc-里controller-和service-职责如何划分" tabindex="-1">mvc 里controller 和service 职责如何划分？ <a class="header-anchor" href="#mvc-里controller-和service-职责如何划分" aria-label="Permalink to &quot;mvc 里controller 和service 职责如何划分？&quot;">​</a></h1><p>一般来说有两种，</p><p>一种是薄Controller，</p><p>一种是厚Controller。前者Controller只负责搜集参数、调用服务、转发或重定向结果集，其他业务逻辑都放在Service层。</p><p>后者则相反，业务逻辑都在Controller中进行处理，服务层只负责一些增删改查的方法。</p><p>两者各有好处，具体情况需要看业务逻辑，如果业务复杂，甚至可以增加多个业务层</p><hr><p>薄的controller，厚的model（service），凡是可能被重复使用的，都放在model，让controller逻辑清晰明了。</p><hr><p>根据不同项目和不同的开发人员习惯，有的时候没有统一的标准。</p><p>对于控制层来说，主要负责的是接收 HTTP 请求，并且对 HTTP 请求参数进行校验。至于具体的业务流程，则需要交给业务层完成。</p><p>但是有的时候，有的开发人员会在控制层不仅仅完成业务数据的校验，而且顺便就完成了业务流程，比如业务流程简单的业务，可能业务校验完成后就已经完成了业务流程。因此业务层有时候在业务较小的项目中就会显得比较尴尬。</p><hr><p>最近负责一个项目，用了 Yii Framework 的 MVC 框架，刚开始自以为结构很稳健。</p><p>但是随着对业务逻辑理解的深入，才开始意识到问题的严重。</p><p>我错误地理解了 MVC 中的 Controller，想当然地根据以往的经验，把所有的业务逻辑都放在 Controller 的 action 中去实现。</p><p><strong>于是，每一个 Controller 的代码都上千行，越来越臃肿</strong>。</p><p><strong>最后，我下定决心重构代码，起源是一个对外开放 API 接口的需求</strong>。</p><p>按照现在的架构，代码基本无法复用，我需要把很多功能再重复写一遍，这实在是无法接受。</p><p>面向对象编程不仅仅是课本上的名词啊！</p><p>真正开始实践才发现，要有面向对象意识，有全局观，是多么难得的一件事情。</p><p><img src="'+t+'" alt="mvc结构图"></p><p>MVC设计原则</p><h2 id="_1-到底什么是-mvc" tabindex="-1">1. 到底什么是 MVC <a class="header-anchor" href="#_1-到底什么是-mvc" aria-label="Permalink to &quot;1. 到底什么是 MVC&quot;">​</a></h2><p>模型-视图-控制器（MVC）是一种设计框架（设计模式）。</p><p>MVC 的目标是将业务逻辑从用户界面的考虑中分离。</p><p>这样，开发者就可以更容易地改变每一部分而不会影响其他。</p><p>在 MVC 中，</p><p>Model 代表数据和业务规则； View 包含了用户界面元素，例如文本，表单等； Controller 则管理模型和视图中的通信。 MVC 在各种编程语言中均有实现，例如 J2EE 应用开发中，</p><p>View 可能由 jsp 实现；Controller 是一个 servlet，现在一般用 Struts 实现；Model 则是由一个实体 Bean 来实现。</p><h2 id="_2-我遇到了什么问题" tabindex="-1">2. 我遇到了什么问题 <a class="header-anchor" href="#_2-我遇到了什么问题" aria-label="Permalink to &quot;2. 我遇到了什么问题&quot;">​</a></h2><p>Yii Framework 是一个流行的 PHP 框架，它借鉴了 Ruby on Rails 的 ActiveRecord(AR) 概念。</p><p>数据库中的每一个 table 都可以用 AR 类来方便地进行增删改查操作。</p><p>它把 AR 当做 Model，并推荐放在一个名为 models 的目录下面。</p><p>于是，我在自动生成表对应的 AR 之后，便望文生义想当然地认为已经拥有了 Model 层。</p><p><strong>其实，AR只不过是 DAO (数据访问层)，并不是 Model 层</strong>。</p><p>我们的业务几乎全放在了 Controller 里：对用户提交上来的表单进行各种逻辑判断，进行计算，实例化 AR 对数据进行存储……</p><p>因为一个 Controller 中会有多个 action，每个 action 都有这样的业务处理。</p><p>最后，我发现我的 Controller 代码已经超过了 1000 行。</p><p>突然有一天，leader 说，我们这个系统要开放 API 给现有的旧系统调用，要给第三方接口。</p><p>第三方只是要给定一个参数，本系统给出个结果值而已，这其中的业务处理它是不关心的。</p><p>坏就坏在这里，Controller 已经实现了那些业务，但它是接受表单提交的，怎样能够也接受 SOAP 的 xml 文档呢？</p><p>Controller 和套套一样，应该越薄越好。</p><p>它的职责应该只是接受用户的输入，然后立刻转发给别的类来处理。</p><p>这样 Controller 只负责提供不同的接口，我们才能算是将业务逻辑分离出去，而分离出去的业务也很容易进行重用。</p><p>分离出来的这部分业务由谁来处理呢？答案应该是 Model。</p><h2 id="_3-view的职责" tabindex="-1">3. View的职责 <a class="header-anchor" href="#_3-view的职责" aria-label="Permalink to &quot;3. View的职责&quot;">​</a></h2><p>View部分比较明确，就是负责显示。</p><p>一切与显示界面无关的东西，都不应该出现在view里面。</p><p>因此，View 中一般不应该出现复杂的判断语句，以及复杂的运算过程。</p><p>可以有简单的循环语句、格式化语句。比如，博客首页的文字列表就是一种循环。</p><p>对于PHP的Web应用而言，HTML是View中的主要内容。</p><p>View应该从不调用Model的写方法。</p><p>也就是说，View只从Model中读取数据，但不改写Model。</p><p>所以我们说，View和Model是老死不相往来的。</p><p>而且，View中不直接访问$_GET和$_POST，应该由Controller传递给View。</p><p>此外，View一般没有任何准备数据处理的内容，如查询数据库等。</p><p>这些一般是放在Controller里面，并以变量的形式传给视图。</p><p>也就是说，视图里面要用到的数据，就是一个变量。</p><h2 id="_4-model的职责" tabindex="-1">4. Model的职责 <a class="header-anchor" href="#_4-model的职责" aria-label="Permalink to &quot;4. Model的职责&quot;">​</a></h2><p>对于Model而言，最主要就是保存和输出信息。</p><p>比如，Post类必然有一个用于保存博客文章标题的title属性，必然有一个删除的操作，这都是Model的内容。</p><p>数据、行为、方法是Model的主要内容。</p><p>实际工作中，Model是MVC中代码量最大。</p><p>Model是逻辑最复杂的地方，因为应用的业务逻辑也要在这里表示。</p><p>注意将Model与Controller区分开。</p><p>Model是处理业务方面的逻辑，Controller只是简单的协调Model和View之间的关系。</p><p>只要是与业务有关的，就该放在Model里面。</p><p><strong>数据校验、public常量和变量，都应该放在model层，</strong></p><p>也就是说，有可能被重复使用的属性或方法，都应该放在model层，一次定义，到处使用。</p><p>Model不应该访问request、session以及其他环境数据，这些应该由Controller注入。</p><p>好的设计，应该是胖Model，瘦Controller。</p><h2 id="_5-controller的职责" tabindex="-1">5. Controller的职责 <a class="header-anchor" href="#_5-controller的职责" aria-label="Permalink to &quot;5. Controller的职责&quot;">​</a></h2><p>对于Controller，<strong>主要是响应用户请求，决定使用什么视图，需要准备什么数据用来显示</strong>。</p><p>因此，对于request的访问代码，应该放在Controller里面，比如$_GET、$_POST等。</p><p>Controller应该仅限于获取用户请求数据，不应该对数据有任何操作或预处理，这应该放在 Model 里面。</p><p>对于数据的写操作，要调用Model类的方法完成。</p><p>对于用户请求的响应，要调用视图渲染。</p><p>此外，一般不要有HTML代码等其他表现层的东西，这应该是属于View的内容。</p><h2 id="_6-启示" tabindex="-1">6. 启示 <a class="header-anchor" href="#_6-启示" aria-label="Permalink to &quot;6. 启示&quot;">​</a></h2><p>Yii Framework 的官方文档中有这么一段：</p><p>In a well-designed MVC application, controllers are often very thin, containing probably only a few dozen lines of code; while models are very fat, containing most of the code responsible for representing and manipulating the data.</p><p>简言之，Rich Model is Better</p><hr><h2 id="评论" tabindex="-1">评论: <a class="header-anchor" href="#评论" aria-label="Permalink to &quot;评论:&quot;">​</a></h2><ol><li><p>可以在model和controller中间加一层business层，处理逻辑都放business更好</p></li><li><p>如果项目不大，可以不加业务逻辑层，如果稍微大一点，加一层层级结构会更加清晰，开发起来也快，很多项目也是这么做的</p></li><li><p>一般是在model里面写数据处理和验证的方法，在controller里面直接调用。</p></li><li><p>可以看看这个。model 也是层结构，可以分为三层 <a href="https://stackoverflow.com/questions/5863870/how-should-a-model-be-structured-in-mvc" target="_blank" rel="noreferrer">https://stackoverflow.com/questions/5863870/how-should-a-model-be-structured-in-mvc</a></p></li><li><p>对于（MVC架构的职责划分原则）我一直很困惑，像你说的，比如有一天，负责人说全部改成api访问，我这个controller应该如何设计才能迅速更改，有例子不，我的理解是再加一层，暂叫service层，service层就是负责从model获取数据并处理，然后提供给控制器，以后要是api的话，只需另写控制器层，从service层拿数据</p></li><li><p>model层的类应该是通用的，比如：(new app\\models\\User)-&gt;getById($id);， 那么这个getById()方法从任何控制器、或者其他model类访问都是一样的。 如果负责人说从api访问，那就重新写（或者新建）控制器，数据还是从model层按照这个方式读取数据。 当然，如果输出格式完全改变了，那就按照你的方法比较合适，新建一个service层，处理api数据格式，这样也不用管原来的model</p></li></ol><hr><h2 id="模型不是什么" tabindex="-1">模型不是什么 <a class="header-anchor" href="#模型不是什么" aria-label="Permalink to &quot;模型不是什么&quot;">​</a></h2><p>模型不是一个类或任何单个对象。这是一个非常常见的错误（我也犯了，尽管最初的答案是在我开始学习时写的），因为大多数框架都延续了这种误解。</p><p>它既不是对象关系映射技术 （ORM），也不是数据库表的抽象。任何告诉你相反的人很可能试图“出售”另一个全新的ORM或整个框架。</p><h2 id="什么是模型" tabindex="-1">什么是模型 <a class="header-anchor" href="#什么是模型" aria-label="Permalink to &quot;什么是模型&quot;">​</a></h2><p>在适当的 MVC 适配中，M 包含所有领域业务逻辑，模型层主要由三种类型的结构组成：</p><p><strong>域对象</strong></p><p>域对象是纯域信息的逻辑容器;它通常表示问题域空间中的逻辑实体。通常称为业务逻辑。</p><p>在这里，您可以定义如何在发送发票之前验证数据，或计算订单的总成本。同时，域对象完全不知道存储 - 无论是从哪里（SQL 数据库、REST API、文本文件等），还是保存或检索它们。</p><p><strong>数据映射器</strong></p><p>这些对象仅负责存储。如果将信息存储在数据库中，则 SQL 将位于此。或者，您可能使用 XML 文件来存储数据，并且您的数据映射器正在解析 XML 文件和向 XML 文件进行解析。</p><p><strong>业务层</strong></p><p>您可以将它们视为“更高级别的域对象”，但服务不是业务逻辑，而是负责域对象和映射器之间的交互。这些结构最终会创建一个“公共”接口，用于与域业务逻辑进行交互。您可以避免它们，但代价是将某些域逻辑泄漏到控制器中。</p><p>在 ACL 实现问题中有一个与此主题相关的答案 - 它可能很有用。</p><p>模型层与 MVC 三元组的其他部分之间的通信应仅通过服务进行。清晰的分离还有一些额外的好处：</p><p>它有助于执行单一责任原则 （SRP）</p><p>提供额外的“回旋余地”，以防逻辑发生变化</p><p>使控制器尽可能简单</p><p>如果您需要外部 API，请给出清晰的蓝图</p>',105)]))}const u=o(a,[["render",i]]);export{M as __pageData,u as default};
