import{_ as e,c as n,a2 as s,o as p}from"./chunks/framework.CqbvlPrP.js";const m=JSON.parse('{"title":"MySQL表设计的经验","description":"","frontmatter":{},"headers":[],"relativePath":"programming/sql/MySQL表设计的经验.md","filePath":"programming/sql/MySQL表设计的经验.md"}'),t={name:"programming/sql/MySQL表设计的经验.md"};function i(l,a,r,o,d,c){return p(),n("div",null,a[0]||(a[0]=[s('<h1 id="mysql表设计的经验" tabindex="-1">MySQL表设计的经验 <a class="header-anchor" href="#mysql表设计的经验" aria-label="Permalink to &quot;MySQL表设计的经验&quot;">​</a></h1><h2 id="_1-命名规范" tabindex="-1">1. 命名规范 <a class="header-anchor" href="#_1-命名规范" aria-label="Permalink to &quot;1. 命名规范&quot;">​</a></h2><p>数据库表名、字段名、索引名等都需要命名规范，可读性高(一般要求用英文)，让别人一看命名，就知道这个字段表示什么意思。 比如一个表的账号字段，反例如下：</p><p><code>acc_no,1_acc_no,zhanghao</code> 正例：</p><p><code>account_no,account_number</code> 表名、字段名必须使用小写字母或者数字，禁止使用数字开头，禁止使用拼音，并且一般不使用英文缩写。 主键索引名为pk_字段名；唯一索引名为uk_字段名；普通索引名则为idx_字段名。</p><h2 id="_2-选择合适的字段类型" tabindex="-1">2. 选择合适的字段类型 <a class="header-anchor" href="#_2-选择合适的字段类型" aria-label="Permalink to &quot;2. 选择合适的字段类型&quot;">​</a></h2><p>设计表时，我们需要选择合适的字段类型，比如：</p><p>尽可能选择存储空间小的字段类型，就好像数字类型的，从tinyint、smallint、int、bigint从左往右开始选择 小数类型如金额，则选择 decimal，禁止使用 float 和 double。 如果存储的字符串长度几乎相等，使用 char 定长字符串类型。 varchar是可变长字符串，不预先分配存储空间，长度不要超过5000。 如果存储的值太大，建议字段类型修改为text，同时抽出单独一张表，用主键与之对应。 同一表中，所有varchar字段的长度加起来，不能大于65535. 如果有这样的需求，请使用TEXT/LONGTEXT 类型。</p><h2 id="_3-主键设计要合理" tabindex="-1">3. 主键设计要合理 <a class="header-anchor" href="#_3-主键设计要合理" aria-label="Permalink to &quot;3. 主键设计要合理&quot;">​</a></h2><p>主键设计的话，最好不要与业务逻辑有所关联。有些业务上的字段，比如身份证，虽然是唯一的，一些开发者喜欢用它来做主键，但是不是很建议哈。主键最好是毫无意义的一串独立不重复的数字，比如UUID，又或者Auto_increment自增的主键，或者是雪花算法生成的主键等等;</p><h2 id="_4-选择合适的字段长度" tabindex="-1">4. 选择合适的字段长度 <a class="header-anchor" href="#_4-选择合适的字段长度" aria-label="Permalink to &quot;4. 选择合适的字段长度&quot;">​</a></h2><p>先问大家一个问题，大家知道数据库字段长度表示字符长度还是字节长度嘛？</p><p>其实在mysql中，varchar和char类型表示字符长度，而其他类型表示的长度都表示字节长度。比如char(10)表示字符长度是10，而bigint（4）表示显示长度是4个字节，但是因为bigint实际长度是8个字节，所以bigint（4）的实际长度就是8个字节。</p><p>我们在设计表的时候，需要充分考虑一个字段的长度，比如一个用户名字段（它的长度5~20个字符），你觉得应该设置多长呢？可以考虑设置为 username varchar（32）。字段长度一般设置为2的幂哈（也就是2的n次方）。</p><h2 id="_5-优先考虑逻辑删除-而不是物理删除" tabindex="-1">5. 优先考虑逻辑删除，而不是物理删除 <a class="header-anchor" href="#_5-优先考虑逻辑删除-而不是物理删除" aria-label="Permalink to &quot;5. 优先考虑逻辑删除，而不是物理删除&quot;">​</a></h2><p>什么是物理删除？什么是逻辑删除？</p><p>物理删除：把数据从硬盘中删除，可释放存储空间 逻辑删除：给数据添加一个字段，比如is_deleted，以标记该数据已经逻辑删除。 物理删除就是执行delete语句，如删除account_no =‘666’的账户信息SQL如下：</p><p><code>delete from account_info_tab whereaccount_no =‘666’;</code> 逻辑删除呢，就是这样：</p><p><code>update account_info_tab set is_deleted = 1 where account_no =‘666’;</code> 为什么推荐用逻辑删除，不推荐物理删除呢？</p><p>为什么不推荐使用物理删除，因为恢复数据很困难 物理删除会使自增主键不再连续 核心业务表 的数据不建议做物理删除，只适合做状态变更。</p><h2 id="_6-每个表都需要添加这几个通用字段如主键、create-time、modifed-time等" tabindex="-1">6. 每个表都需要添加这几个通用字段如主键、create_time、modifed_time等 <a class="header-anchor" href="#_6-每个表都需要添加这几个通用字段如主键、create-time、modifed-time等" aria-label="Permalink to &quot;6. 每个表都需要添加这几个通用字段如主键、create_time、modifed_time等&quot;">​</a></h2><p>表必备一般来说，或具备这几个字段：</p><p>id： 主键，一个表必须得有主键，必须 create_time： 创建时间，必须 modifed_time: 修改时间，必须，更新记录时，需要更新它 version : 数据记录的版本号，用于乐观锁，非必须 remark ：数据记录备注，非必须 modified_by :修改人，非必须 creator ：创建人，非必须</p><h2 id="_7-一张表的字段不宜过多" tabindex="-1">7. 一张表的字段不宜过多 <a class="header-anchor" href="#_7-一张表的字段不宜过多" aria-label="Permalink to &quot;7. 一张表的字段不宜过多&quot;">​</a></h2><p>我们建表的时候，要牢记，一张表的字段不宜过多哈，一般尽量不要超过20个字段。</p><p>如果一张表的字段过多，表中保存的数据可能就会很大，查询效率就会很低。因此，一张表不要设计太多字段哈，如果业务需求，实在需要很多字段，可以把一张大的表，拆成多张小的表，它们的主键相同即可。</p><p>当表的字段数非常多时，可以将表分成两张表，一张作为条件查询表，一张作为详细内容表 (主要是为了性能考虑)。</p><h2 id="_8-尽可能使用not-null定义字段" tabindex="-1">8. 尽可能使用not null定义字段 <a class="header-anchor" href="#_8-尽可能使用not-null定义字段" aria-label="Permalink to &quot;8. 尽可能使用not null定义字段&quot;">​</a></h2><p>如果没有特殊的理由， 一般都建议将字段定义为 NOT NULL 。 为什么呢？</p><p>首先， NOT NULL 可以防止出现空指针问题。 其次，NULL值存储也需要额外的空间的，它也会导致比较运算更为复杂，使优化器难以优化SQL。 NULL值有可能会导致索引失效 如果将字段默认设置成一个空字符串或常量值并没有什么不同，且都不会影响到应用逻辑， 那就可以将这个字段设置为NOT NULL。</p><h2 id="_9-设计表时-评估哪些字段需要加索引" tabindex="-1">9. 设计表时，评估哪些字段需要加索引 <a class="header-anchor" href="#_9-设计表时-评估哪些字段需要加索引" aria-label="Permalink to &quot;9. 设计表时，评估哪些字段需要加索引&quot;">​</a></h2><p>首先，评估你的表数据量。如果你的表数据量只有一百几十行，就没有必要加索引。否则设计表的时候，如果有查询条件的字段，一般就需要建立索引。但是索引也不能滥用：</p><p>索引也不要建得太多，一般单表索引个数不要超过5个。因为创建过多的索引，会降低写得速度。 区分度不高的字段，不能加索引，如性别等 索引创建完后，还是要注意避免索引失效的情况，如使用mysql的内置函数，会导致索引失效的 索引过多的话，可以通过联合索引的话方式来优化。然后的话，索引还有一些规则，如覆盖索引，最左匹配原则等等。 假设你新建一张用户表，如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE TABLE user_info_tab (</span></span>\n<span class="line"><span>  `id` int(11) NOT NULL AUTO_INCREMENT,</span></span>\n<span class="line"><span>  `user_id` int(11) NOT NULL,</span></span>\n<span class="line"><span>  `age` int(11) DEFAULT NULL,</span></span>\n<span class="line"><span>  `name` varchar(255) NOT NULL,</span></span>\n<span class="line"><span>  `create_time` datetime NOT NULL,</span></span>\n<span class="line"><span>  `modifed_time` datetime NOT NULL,</span></span>\n<span class="line"><span>  PRIMARY KEY (`id`)</span></span>\n<span class="line"><span>) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span></span></code></pre></div><p>对于这张表，很可能会有根据user_id或者name查询用户信息，并且，user_id是唯一的。因此，你是可以给user_id加上唯一索引，name加上普通索引。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE TABLE user_info_tab (</span></span>\n<span class="line"><span>  `id` int(11) NOT NULL AUTO_INCREMENT,</span></span>\n<span class="line"><span>  `user_id` int(11) NOT NULL,</span></span>\n<span class="line"><span>  `age` int(11) DEFAULT NULL,</span></span>\n<span class="line"><span>  `name` varchar(255) NOT NULL,</span></span>\n<span class="line"><span>  `create_time` datetime NOT NULL,</span></span>\n<span class="line"><span>  `modifed_time` datetime NOT NULL,</span></span>\n<span class="line"><span>  PRIMARY KEY (`id`),</span></span>\n<span class="line"><span>  KEY `idx_name` (`name`) USING BTREE,</span></span>\n<span class="line"><span>  UNIQUE KEY un_user_id (user_id)</span></span>\n<span class="line"><span>) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span></span></code></pre></div><h2 id="_10-不需要严格遵守-3nf-通过业务字段冗余来减少表关联" tabindex="-1">10. 不需要严格遵守 3NF，通过业务字段冗余来减少表关联 <a class="header-anchor" href="#_10-不需要严格遵守-3nf-通过业务字段冗余来减少表关联" aria-label="Permalink to &quot;10. 不需要严格遵守 3NF，通过业务字段冗余来减少表关联&quot;">​</a></h2><p>什么是数据库三范式（3NF），大家是否还有印象吗？</p><p>第一范式：对属性的原子性，要求属性具有原子性，不可再分解； 第二范式：对记录的唯一性，要求记录有唯一标识，即实体的唯一性，即不存在部分依赖； 第三方式：对字段的冗余性，要求任何字段不能由其他字段派生出来，它要求字段没有冗余，即不存在传递依赖； 我们设计表及其字段之间的关系, 应尽量满足第三范式。但是有时候，可以适当冗余，来提高效率。比如以下这张表</p><p>商品名称 商品型号 单价 数量 总金额 手机 华为 8000 5 40000 以上这张存放商品信息的基本表。总金额这个字段的存在，表明该表的设计不满足第三范式，因为总金额可以由单价*数量得到，说明总金额是冗余字段。但是，增加总金额这个冗余字段，可以提高查询统计的速度，这就是以空间换时间的作法。 当然，这只是个小例子哈，大家开发设计的时候，要结合具体业务哈。</p><h2 id="_11-避免使用mysql保留字" tabindex="-1">11. 避免使用MySQL保留字 <a class="header-anchor" href="#_11-避免使用mysql保留字" aria-label="Permalink to &quot;11. 避免使用MySQL保留字&quot;">​</a></h2><p>如果库名、表名、字段名等属性含有保留字时，SQL语句必须用反引号来引用属性名称，这将使得SQL语句书写、SHELL脚本中变量的转义等变得非常复杂。</p><p>因此，我们一般避免使用MySQL保留字，如select、interval、desc等等</p><h2 id="_12-不搞外键关联-一般都在代码维护" tabindex="-1">12. 不搞外键关联，一般都在代码维护 <a class="header-anchor" href="#_12-不搞外键关联-一般都在代码维护" aria-label="Permalink to &quot;12. 不搞外键关联，一般都在代码维护&quot;">​</a></h2><p>什么是外键呢？</p><p>外键，也叫FOREIGN KEY，它是用于将两个表连接在一起的键。FOREIGN KEY是一个表中的一个字段（或字段集合），它引用另一个表中的PRIMARY KEY。它是用来保证数据的一致性和完整性的。</p><p>阿里的Java规范也有这么一条：</p><p>【强制】不得使用外键与级联，一切外键概念必须在应用层解决。</p><p>我们为什么不推荐使用外键呢？</p><p>使用外键存在性能问题、并发死锁问题、使用起来不方便等等。每次做DELETE或者UPDATE都必须考虑外键约束，会导致开发的时候很难受,测试数据造数据也不方便。 还有一个场景不能使用外键，就是分库分表。</p><h2 id="_13-一般都选择innodb存储引擎" tabindex="-1">13. 一般都选择INNODB存储引擎 <a class="header-anchor" href="#_13-一般都选择innodb存储引擎" aria-label="Permalink to &quot;13. 一般都选择INNODB存储引擎&quot;">​</a></h2><p>建表是需要选择存储引擎的，我们一般都选择INNODB存储引擎，除非读写比率小于1%, 才考虑使用MyISAM 。</p><p>有些小伙伴可能会有疑惑，不是还有MEMORY等其他存储引擎吗？什么时候使用它呢？其实其他存储引擎一般除了都建议在DBA的指导下使用。 我们来复习一下这MySQL这三种存储引擎的对比区别吧：</p><p>特性 INNODB MyISAM MEMORY 事务安全 支持 无 无 存储限制 64TB 有 有 空间使用 高 低 低 内存使用 高 低 高 插入数据速度 低 高 高 是否支持外键 支持 无 无</p><h2 id="_14-选择合适统一的字符集。" tabindex="-1">14. 选择合适统一的字符集。 <a class="header-anchor" href="#_14-选择合适统一的字符集。" aria-label="Permalink to &quot;14. 选择合适统一的字符集。&quot;">​</a></h2><p>数据库库、表、开发程序等都需要统一字符集，通常中英文环境用utf8。 MySQL支持的字符集有utf8、utf8mb4、GBK、latin1等。</p><p>utf8：支持中英文混合场景，国际通过，3个字节长度 utf8mb4: 完全兼容utf8，4个字节长度，一般存储emoji表情需要用到它。 GBK ：支持中文，但是不支持国际通用字符集，2个字节长度 latin1：MySQL默认字符集，1个字节长度 15. 如果你的数据库字段是枚举类型的，需要在comment注释清楚 如果你设计的数据库字段是枚举类型的话，就需要在comment后面注释清楚每个枚举的意思，以便于维护 正例如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>`session_status` varchar(2) COLLATE utf8_bin NOT NULL COMMENT &#39;session授权态 00：在线-授权态有效 01：下线-授权态失效 02：下线-主动退出 03：下线-在别处被登录&#39;</span></span></code></pre></div><p>反例：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>`session_status` varchar(2) COLLATE utf8_bin NOT NULL COMMENT &#39;session授权态&#39;</span></span></code></pre></div><p>并且，如果你的枚举类型在未来的版本有增加修改的话，也需要同时维护到comment。</p><h2 id="_16-时间的类型选择" tabindex="-1">16. 时间的类型选择 <a class="header-anchor" href="#_16-时间的类型选择" aria-label="Permalink to &quot;16. 时间的类型选择&quot;">​</a></h2><p>我们设计表的时候，一般都需要加通用时间的字段，如create_time、modified_time等等。那对于时间的类型，我们该如何选择呢？ 对于MySQL来说，主要有date、datetime、time、timestamp 和 year。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>date ：表示的日期值, 格式yyyy-mm-dd,范围1000-01-01 到 9999-12-31，3字节</span></span>\n<span class="line"><span>time ：表示的时间值，格式 hh:mm:ss，范围-838:59:59 到 838:59:59，3字节</span></span>\n<span class="line"><span>datetime：表示的日期时间值，格式yyyy-mm-dd hh:mm:ss，范围1000-01-01 00:00:00到9999-12-31 23:59:59,8字节，跟时区无关</span></span>\n<span class="line"><span>timestamp：表示的时间戳值，格式为yyyymmddhhmmss，范围1970-01-01 00:00:01到2038-01-19 03:14:07，4字节，跟时区有关</span></span>\n<span class="line"><span>year：年份值，格式为yyyy。范围1901到2155，1字节</span></span></code></pre></div><p>推荐优先使用datetime类型来保存日期和时间，因为存储范围更大，且跟时区无关。</p><h2 id="_17-不建议使用stored-procedure-包括存储过程-触发器-。" tabindex="-1">17. 不建议使用Stored procedure (包括存储过程，触发器) 。 <a class="header-anchor" href="#_17-不建议使用stored-procedure-包括存储过程-触发器-。" aria-label="Permalink to &quot;17. 不建议使用Stored procedure (包括存储过程，触发器) 。&quot;">​</a></h2><p>什么是存储过程 已预编译为一个可执行过程的一个或多个SQL语句。</p><p>什么是触发器 触发器，指一段代码，当触发某个事件时，自动执行这些代码。使用场景：</p><p>可以通过数据库中的相关表实现级联更改。 实时监控某张表中的某个字段的更改而需要做出相应的处理。 例如可以生成某些业务的编号。 注意不要滥用，否则会造成数据库及应用程序的维护困难。 对于MYSQL来说，存储过程、触发器等还不是很成熟， 并没有完善的出错记录处理，不建议使用。</p><h2 id="_18-1-n-关系的设计" tabindex="-1">18. 1:N 关系的设计 <a class="header-anchor" href="#_18-1-n-关系的设计" aria-label="Permalink to &quot;18. 1:N 关系的设计&quot;">​</a></h2><p>日常开发中，1对多的关系应该是非常常见的。比如一个班级有多个学生，一个部门有多个员工等等。这种的建表原则就是： 在从表（N的这一方）创建一个字段，以字段作为外键指向主表（1的这一方）的主键。示意图如下:</p><p>学生表是多（N）的一方，会有个字段class_id保存班级表的主键。当然，一班不加外键约束哈，只是单纯保存这个关系而已。</p><p>有时候两张表存在N:N关系时，我们应该消除这种关系。通过增加第三张表，把N:N修改为两个 1:N。比如图书和读者，是一个典型的多对多的关系。一本书可以被多个读者借，一个读者又可以借多本书。我们就可以设计一个借书表，包含图书表的主键，以及读者的主键，以及借还标记等字段。</p><h2 id="_19-大字段" tabindex="-1">19. 大字段 <a class="header-anchor" href="#_19-大字段" aria-label="Permalink to &quot;19. 大字段&quot;">​</a></h2><p>设计表的时候，我们尤其需要关注一些大字段，即占用较多存储空间的字段。比如用来记录用户评论的字段，又或者记录博客内容的字段，又或者保存合同数据的字段。如果直接把表字段设计成text类型的话，就会浪费存储空间，查询效率也不好。</p><p>在MySQl中，这种方式保存的设计方案，其实是不太合理的。这种非常大的数据，可以保存到mongodb中，然后，在业务表保存对应mongodb的id即可。</p><p>这种设计思想类似于，我们表字段保存图片时，为什么不是保存图片内容，而是直接保存图片url即可。</p><h2 id="_20-考虑是否需要分库分表" tabindex="-1">20. 考虑是否需要分库分表 <a class="header-anchor" href="#_20-考虑是否需要分库分表" aria-label="Permalink to &quot;20. 考虑是否需要分库分表&quot;">​</a></h2><p>什么是分库分表呢？</p><p>分库：就是一个数据库分成多个数据库，部署到不同机器。</p><p>分表：就是一个数据库表分成多个表。</p><p>我们在设计表的时候，其实可以提前估算一下，是否需要做分库分表。比如一些用户信息，未来可能数据量到达百万设置千万的话，就可以提前考虑分库分表。</p><p>为什么需要分库分表: 数据量太大的话，SQL的查询就会变慢。如果一个查询SQL没命中索引，千百万数据量级别的表可能会拖垮整个数据库。即使SQL命中了索引，如果表的数据量超过一千万的话，查询也是会明显变慢的。这是因为索引一般是B+树结构，数据千万级别的话，B+树的高度会增高，查询就变慢啦。</p><p>分库分表主要有水平拆分、垂直拆分的说法，拆分策略有range范围、hash取模。而分库分表主要有这些问题：</p><p>事务问题 跨库关联 排序问题 分页问题 分布式ID</p><h2 id="_21-sql-编写的一些优化经验" tabindex="-1">21. sqL 编写的一些优化经验 <a class="header-anchor" href="#_21-sql-编写的一些优化经验" aria-label="Permalink to &quot;21. sqL 编写的一些优化经验&quot;">​</a></h2><p>最后的话，跟大家聊来一些写SQL的经验吧：</p><p>查询SQL尽量不要使用select *，而是select具体字段 如果知道查询结果只有一条或者只要最大/最小一条记录，建议用limit 1 应尽量避免在where子句中使用or来连接条件 注意优化limit深分页问题 使用where条件限定要查询的数据，避免返回多余的行 尽量避免在索引列上使用mysql的内置函数 应尽量避免在 where子句中对字段进行表达式操作 应尽量避免在where 子句中使用!=或&lt;&gt;操作符 使用联合索引时，注意索引列的顺序，一般遵循最左匹配原则。 对查询进行优化，应考虑在where 及 order by涉及的列上建立索引 如果插入数据过多，考虑批量插入 在适当的时候，使用覆盖索引 使用explain 分析你SQL的计划</p>',88)]))}const u=e(t,[["render",i]]);export{m as __pageData,u as default};
