import{_ as e,c as s,a2 as i,o as l}from"./chunks/framework.CqbvlPrP.js";const a="/assets/img/program/sql/%E6%B0%B4%E5%B9%B3%E9%93%BE%E6%8E%A5%E8%A1%A8/1.png",n="/assets/img/program/sql/%E6%B0%B4%E5%B9%B3%E9%93%BE%E6%8E%A5%E8%A1%A8/2.png",o=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"programming/sql/水平链接表查询.md","filePath":"programming/sql/水平链接表查询.md"}'),d={name:"programming/sql/水平链接表查询.md"};function r(h,t,p,g,y,k){return l(),s("div",null,t[0]||(t[0]=[i('<h3 id="sql使用inner-join-left-join-等" tabindex="-1">SQL使用inner join，left join 等 <a class="header-anchor" href="#sql使用inner-join-left-join-等" aria-label="Permalink to &quot;SQL使用inner join，left join 等&quot;">​</a></h3><p>sql之left join、right join、inner join的区别 union、union all的区别跳转<a href="https://www.cnblogs.com/logon/p/3748020.html" target="_blank" rel="noreferrer">https://www.cnblogs.com/logon/p/3748020.html</a></p><p>SQL JOINS:</p><p><img src="'+a+'" alt="join"></p><p><a href="https://www.codeproject.com/Articles/33052/Visual-Representation-of-SQL-Joins" target="_blank" rel="noreferrer">Please refer the link </a></p><p>如图： <img src="'+n+`" alt="join"></p><p><strong>left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录 right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录 inner join(等值连接) 只返回两个表中联结字段相等的行</strong></p><h4 id="举例如下" tabindex="-1">举例如下： <a class="header-anchor" href="#举例如下" aria-label="Permalink to &quot;举例如下：&quot;">​</a></h4><hr><p>表A记录如下：</p><table tabindex="0"><thead><tr><th style="text-align:left;">aID</th><th style="text-align:center;">aNum</th></tr></thead><tbody><tr><td style="text-align:left;">1</td><td style="text-align:center;">a20050111</td></tr><tr><td style="text-align:left;">2</td><td style="text-align:center;">a20050112</td></tr><tr><td style="text-align:left;">3</td><td style="text-align:center;">a20050113</td></tr><tr><td style="text-align:left;">4</td><td style="text-align:center;">a20050114</td></tr><tr><td style="text-align:left;">5</td><td style="text-align:center;">a20050115</td></tr></tbody></table><p>表B记录如下:</p><table tabindex="0"><thead><tr><th style="text-align:left;">bID</th><th style="text-align:center;">bName</th></tr></thead><tbody><tr><td style="text-align:left;">1</td><td style="text-align:center;">2006032401</td></tr><tr><td style="text-align:left;">2</td><td style="text-align:center;">2006032402</td></tr><tr><td style="text-align:left;">3</td><td style="text-align:center;">2006032403</td></tr><tr><td style="text-align:left;">4</td><td style="text-align:center;">2006032404</td></tr><tr><td style="text-align:left;">8</td><td style="text-align:center;">2006032408</td></tr></tbody></table><hr><p>1.left join sql语句如下:</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">select</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> A</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">left join</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> B </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">on</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> A</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">aID</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> B</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">bID</span></span></code></pre></div><p>结果如下:</p><table tabindex="0"><thead><tr><th style="text-align:left;">aID</th><th style="text-align:center;">aNum</th><th style="text-align:center;">bID</th><th style="text-align:center;">bName</th></tr></thead><tbody><tr><td style="text-align:left;">1</td><td style="text-align:center;">a20050111</td><td style="text-align:center;">1</td><td style="text-align:center;">2006032401</td></tr><tr><td style="text-align:left;">2</td><td style="text-align:center;">a20050112</td><td style="text-align:center;">2</td><td style="text-align:center;">2006032402</td></tr><tr><td style="text-align:left;">3</td><td style="text-align:center;">a20050113</td><td style="text-align:center;">3</td><td style="text-align:center;">2006032403</td></tr><tr><td style="text-align:left;">4</td><td style="text-align:center;">a20050114</td><td style="text-align:center;">4</td><td style="text-align:center;">2006032404</td></tr><tr><td style="text-align:left;">5</td><td style="text-align:center;">a20050115</td><td style="text-align:center;">NULL</td><td style="text-align:center;">NULL</td></tr></tbody></table><p>（所影响的行数为 5 行） 结果说明:</p><blockquote><p>left join是以A表的记录为基础的,A可以看成左表,B可以看成右表,left join是以左表为准的. 换句话说,左表(A)的记录将会全部表示出来,而右表(B)只会显示符合搜索条件的记录(例子中为: A.aID = B.bID). B表记录不足的地方均为NULL.</p></blockquote><hr><p>2.right join sql语句如下:</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">select</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> A</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">right join</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> B </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">on</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> A</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">aID</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> B</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">bID</span></span></code></pre></div><p>结果如下:</p><table tabindex="0"><thead><tr><th style="text-align:left;">aID</th><th style="text-align:center;">aNum</th><th style="text-align:center;">bID</th><th style="text-align:center;">bName</th></tr></thead><tbody><tr><td style="text-align:left;">1</td><td style="text-align:center;">a20050111</td><td style="text-align:center;">1</td><td style="text-align:center;">2006032401</td></tr><tr><td style="text-align:left;">2</td><td style="text-align:center;">a20050112</td><td style="text-align:center;">2</td><td style="text-align:center;">2006032402</td></tr><tr><td style="text-align:left;">3</td><td style="text-align:center;">a20050113</td><td style="text-align:center;">3</td><td style="text-align:center;">2006032403</td></tr><tr><td style="text-align:left;">4</td><td style="text-align:center;">a20050114</td><td style="text-align:center;">4</td><td style="text-align:center;">2006032404</td></tr><tr><td style="text-align:left;">NULL</td><td style="text-align:center;">NULL</td><td style="text-align:center;">8</td><td style="text-align:center;">2006032408</td></tr></tbody></table><p>（所影响的行数为 5 行）</p><p>结果说明:</p><blockquote><p>仔细观察一下,就会发现,和left join的结果刚好相反,这次是以右表(B)为基础的,A表不足的地方用NULL填充.</p></blockquote><hr><p>3.inner join sql语句如下:</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">select</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> A</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">innerjoin B </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">on</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> A</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">aID</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> B</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">bID</span></span></code></pre></div><p>结果如下:</p><table tabindex="0"><thead><tr><th style="text-align:left;">aID</th><th style="text-align:center;">aNum</th><th style="text-align:center;">bID</th><th style="text-align:center;">bName</th></tr></thead><tbody><tr><td style="text-align:left;">1</td><td style="text-align:center;">a20050111</td><td style="text-align:center;">1</td><td style="text-align:center;">2006032401</td></tr><tr><td style="text-align:left;">2</td><td style="text-align:center;">a20050112</td><td style="text-align:center;">2</td><td style="text-align:center;">2006032402</td></tr><tr><td style="text-align:left;">3</td><td style="text-align:center;">a20050113</td><td style="text-align:center;">3</td><td style="text-align:center;">2006032403</td></tr><tr><td style="text-align:left;">4</td><td style="text-align:center;">a20050114</td><td style="text-align:center;">4</td><td style="text-align:center;">2006032404</td></tr></tbody></table><p>结果说明:</p><blockquote><p>很明显,这里只显示出了 A.aID = B.bID的记录.这说明inner join并不以谁为基础,它只显示符合条件的记录.</p></blockquote><hr><p>注: LEFT JOIN操作用于在任何的 FROM 子句中，组合来源表的记录。使用 LEFT JOIN 运算来创建一个左边外部联接。左边外部联接将包含了从第一个（左边）开始的两个表中的全部记录，即使在第二个（右边）表中并没有相符值的记录。</p>`,37)]))}const x=e(d,[["render",r]]);export{o as __pageData,x as default};
