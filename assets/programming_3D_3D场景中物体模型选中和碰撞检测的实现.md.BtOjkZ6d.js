import{_ as n,c as a,a2 as p,o as e}from"./chunks/framework.CqbvlPrP.js";const i="/assets/img/program/3D/%E5%85%89%E7%BA%BF%E6%8A%95%E5%B0%84%E7%AE%97%E6%B3%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png",h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"programming/3D/3D场景中物体模型选中和碰撞检测的实现.md","filePath":"programming/3D/3D场景中物体模型选中和碰撞检测的实现.md"}'),t={name:"programming/3D/3D场景中物体模型选中和碰撞检测的实现.md"};function c(r,s,o,l,d,g){return e(),a("div",null,s[0]||(s[0]=[p('<h3 id="_3d场景中物体模型选中和碰撞检测的实现" tabindex="-1">3D场景中物体模型选中和碰撞检测的实现 <a class="header-anchor" href="#_3d场景中物体模型选中和碰撞检测的实现" aria-label="Permalink to &quot;3D场景中物体模型选中和碰撞检测的实现&quot;">​</a></h3><p>在3D场景中常用的一个需求就是鼠标在屏幕上点击特定位置，选中一个物体模型，进行下一步的操作。比如说移动、旋转变形或者改变物体模型渲染外观等等。具体怎么实现呢？这涉及到把二维坐标转换到三维场景里，进行检测找到选择的模型。</p><p>在threejs世界里，处理这样的场景就非常简单了，今天介绍一下这个类“<code>Raycaster</code>”。</p><p>光线投射器（<code>Raycaster</code>）</p><p><em><strong>该类用来处理光线投射。光线投射主要用于物体选择、碰撞检测以及图像成像等方面。</strong></em></p><p>光线投射方法是基于图像序列的直接体绘制（Volume Rendering）算法。</p><p><strong>从图像的每一个像素，沿固定方向（通常是视线方向）发射一条光线，光线穿越整个图像序列</strong>，</p><p>并在这个过程中，对图像序列进行采样获取颜色信息，同时依据光线吸收模型将颜色值进行累加，直至光线穿越整个图像序列，最后得到的颜色值就是渲染图像的颜色。</p><p>光线投射的基本步骤可以分为如下4步：</p><p>光线投射（<code>Ray casting</code>）：对最终图像的每个像素，都有一条光线穿过体素。在这一阶段，认为像素被接触并封闭于一个包围图元中是有帮助的：一个简单的几何对象（通常是一个长方体）用来与光线和体相交。</p><p>采样（<code>Sampling</code>）：沿着光线的射线部分位于体的内部，等距离的点采样被选择。通常体和表示光线的射线对齐，样本点通常被放于体素中间。因此，有必要对从它周围的体素的样本点的值进行插值。</p><p>着色（<code>Shading</code>）：对每个样本点，计算出梯度。这些代表体内局部表面的方向。然后给这些样本着色，也就是根据它们的表面方向和实际的光源添加阴影和颜色。</p><p>组合（<code>Compositing</code>）：在所有的样本点被着色后，沿着光线组合它们，得到该像素最终的颜色值。</p><p>这个过程被不断重复。计算开始于视图中最远的样本点，并且结束于最近的一个。这个工作流水线会确保被遮挡的体部分不影响上述过程得到的结果像素。</p><p><img src="'+i+`" alt="图片"></p><hr><p>构造器（Constructor）</p><p>Raycaster( origin, direction, near, far ) {</p><p>origin — 光线投射的起点向量。</p><p>direction — 光线投射的方向向量，应该是被归一化的。</p><p>near — 投射近点，用来限定返回比near要远的结果。near不能为负数。缺省为0。</p><p>far — 投射远点，用来限定返回比far要近的结果。far不能比near要小。缺省为无穷大。</p><p>这将创建一个新的光线投射器对象。</p><p>属性（Properties）</p><p>#.ray</p><p>用于光线投射的射线。</p><p>#.near</p><p>光线投射器的近点因子，这个值指示基于这个距离哪些对象可以被舍弃。</p><p>这个值不能是负的，且应该小于far属性。</p><p>#.far</p><p>光线投射器的远点因子，这个值指示基于这个距离哪些对象可以被舍弃。</p><p>这个值不能是负的，且应该大于near属性。</p><p>.linePrecision</p><p>和 线条(Line) 对象相交时的精度因子。</p><p>方法（Methods）</p><p>#.set ( origin, direction )</p><p>origin — 光线投射的起点向量。</p><p>direction — 被归一化的光线投射的方向向量。</p><p>用一个新的起点和方向向量来更新射线（ray）。</p><p>#.setFromCamera ( coords, camera )</p><p>coords — 鼠标的二维坐标，在归一化的设备坐标(NDC)中，也就是X 和 Y 分量应该介于 -1 和 1 之间。</p><p>camera — 射线起点处的相机，即把射线起点设置在该相机位置处。</p><p>用一个新的原点和方向向量来更新射线（ray）。</p><p>#.intersectObject ( object, recursive )</p><p>object — 用来检测和射线相交的物体。</p><p>recursive — 如果为true，它还检查所有后代。否则只检查该对象本身。缺省值为false。</p><p>检查射线和物体之间的所有交叉点（包含或不包含后代）。交叉点返回按距离排序，最接近的为第一个。返回一个交叉点对象数组。</p><p>[ { distance, point, face, faceIndex, indices, object }, ... ]</p><p>distance – 射线的起点到相交点的距离</p><p>point – 在世界坐标中的交叉点</p><p>face – 相交的面</p><p>faceIndex – 相交的面的索引</p><p>indices – 组成相交面的顶点索引</p><p>object – 相交的对象</p><hr><p>当一个网孔(Mesh)对象和一个缓存几何模型(BufferGeometry)相交时，faceIndex 将是 undefined，并且 indices 将被设置；而当一个网孔(Mesh)对象和一个几何模型(Geometry)相交时，indices 将是 undefined。</p><p>当计算这个对象是否和射线相交时，Raycaster 把传递的对象委托给 raycast 方法。这允许 meshes 对于光线投射的响应可以不同于 lines 和 pointclouds。</p><p><strong>注意</strong>，对于网格，面（faces）必须朝向射线原点，这样才能被检测到；通过背面的射线的交叉点将不被检测到。为了光线投射一个对象的正反两面，你得设置 material 的 side 属性为 THREE.DoubleSide。</p><hr><p>#.intersectObjects ( objects, recursive )</p><p>objects — 检查是否和射线相交的一组对象。</p><p>recursive — 如果为true，还同时检查所有的后代对象。否则只检查对象本身。缺省值为 false。</p><hr><p>检查射线和对象之间的所有交叉点（包含或不包含后代）。交叉点返回按距离排序，最接近的为第一个。返回结果类似于 .intersectObject。</p><p>我们使用上次场景里（如何实现一个3d场景中的阴影效果（threejs）？）的示例，增加鼠标点击选中物体模型，改变模型渲染颜色，及让模型向上移动一部分位置的功能。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>添加鼠标事件：</span></span>
<span class="line"><span></span></span>
<span class="line"><span>声明raycaster和mouse变量</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    //声明raycaster和mouse变量</span></span>
<span class="line"><span>    var raycaster = new THREE.Raycaster();</span></span>
<span class="line"><span>    var mouse = new THREE.Vector2();</span></span></code></pre></div><p>添加鼠标点击事件</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>function onMouseClick( event ) {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    //通过鼠标点击的位置计算出raycaster所需要的点的位置，以屏幕中心为原点，值的范围为-1到1.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;</span></span>
<span class="line"><span>    mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 通过鼠标点的位置和当前相机的矩阵计算出raycaster</span></span>
<span class="line"><span>    raycaster.setFromCamera( mouse, camera );</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 获取raycaster直线和所有模型相交的数组集合</span></span>
<span class="line"><span>    var intersects = raycaster.intersectObjects( scene.children );</span></span>
<span class="line"><span>    for ( var i = 0; i &lt; intersects.length; i++ ) {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        if(intersects[ i ].object.name == &quot;plane&quot;){</span></span>
<span class="line"><span>            break;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        intersects[ i ].object.material.color.set( 0xff4577 );</span></span>
<span class="line"><span>        intersects[ i ].object.position.y = intersects[ i ].object.position.y + 10;</span></span>
<span class="line"><span>        break;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>window.addEventListener( &#39;click&#39;, onMouseClick, false );</span></span></code></pre></div><p>注意这句话：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> var intersects = raycaster.intersectObjects( scene.children );</span></span></code></pre></div><p>THREE.Raycaster对象从屏幕上的点击位置向场景中发射一束光线。</p><p>intersects 变量返回被击中对象的信息，来判断指定对象有没有被这束光线击中，相交的结果会以一个数组的形式返回，其中的元素依照距离排序，越近的排在越前。</p><p>方法名</p><p>.intersectObject ( object, recursive : Boolean, optionalTarget : Array )</p><p>参数</p><p>object - 检测与射线相交的物体</p><p>recursive- 若为 true 则检查后代对象，默认值为false</p><p>optionalTarget - （可选参数）用来设置方法返回的设置结果。若不设置则返回一个实例化的数组。如果设置，必须在每次调用之前清除这个数组（例如，array.length= 0;)</p><p>注意，对于网格，面（faces）必须朝向射线原点，这样才能被检测到；通过背面的射线的交叉点将不被检测到。为了光线投射一个对象的正反两面，你得设置 material 的 side 属性为 THREE.DoubleSide</p><p>返回值：</p><p>[ { distance, point, face, faceIndex, object }, … ]</p><p>distance - 射线的起点到相交点的距离</p><p>point - 在世界坐标中的交叉点</p><p>face -相交的面</p><p>faceIndex - 相交的面的索引</p><p>object - 相交的对象</p><p>uv - 交点的二维坐标</p><p>可以根据返回对象face属性，确定点击位置所处的模型的面。</p><p>比如在前面场景中增加一个功能，点击立方体的某个面让立方体超点击面的反方向移动。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>if(JSON.stringify(intersects[ i ].face.normal) ==  JSON.stringify(new THREE.Vector3(0,0,1)))</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    intersects[ i ].object.position.z = intersects[ i ].object.position.z - 10;</span></span>
<span class="line"><span>    break;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>if(JSON.stringify(intersects[ i ].face.normal) ==  JSON.stringify(new THREE.Vector3(0,0,-1)))</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    intersects[ i ].object.position.z = intersects[ i ].object.position.z + 10;</span></span>
<span class="line"><span>    break;</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>点击立方体的前后两个面，可以控制立方体前后移动。</p><p>用Raycaster来检测碰撞的原理很简单，我们需要以物体的中心为起点，向各个顶点（vertices）发出射线，然后检查射线是否与其它的物体相交。如果出现了相交的情况，检查最近的一个交点与射线起点间的距离，如果这个距离比射线起点至物体顶点间的距离要小，则说明发生了碰撞。</p>`,93)]))}const b=n(t,[["render",c]]);export{h as __pageData,b as default};
